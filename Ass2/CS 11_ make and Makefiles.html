<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0066)http://courses.cms.caltech.edu/cs11/material/c/mike/misc/make.html -->
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>CS 11: make and Makefiles</title>
</head>

<body>

<center>
<h1>C track: Using the <code>make</code> program.</h1>
</center>
<hr>

<p>Any C program of any size will normally be compiled not by invoking
<code>gcc</code> from the command line but by using a program called
<code>make</code> and a file called a "makefile".  The name for a makefile is
normally either <code>Makefile</code> or <code>makefile</code> (pretty
imaginative, huh?).  We will use <code>Makefile</code> for the name of the
makefile; this makes it easier to see when you list the files in the
directory.</p>

<p>The purpose of <code>make</code> is to simplify the process of rebuilding
a program (<i>i.e.</i> a binary executable) from its source code, and to
ensure that only source code that has been modified gets recompiled.  This is
not a big deal when you're dealing with a small number of source files, but
when a program is split into tens or even hundreds of source code files
(which is very common for large projects), it becomes a big deal very
quickly.</p>

<p><code>make</code> is a somewhat complicated program (it's really a
miniature computer language of its own, completely distinct from C), so we
will only cover the most rudimentary aspects of it here and refer you to the
references when you need to know more.  Much of the following material has
been borrowed from the GNU make documentation.  Also, you should realize that
it isn't strictly necessary to use <code>make</code> when compiling C
programs; it just makes the job much easier.</p>

<h2>Prerequisites</h2>

<p>You should understand the basics of compiling C programs.  You should know
the difference between source code files (<code>.c</code> and <code>.h</code>
(header) files) and object files, and how to compile C programs in stages
(first the object files, then the executable).  If you are unclear on this
material, read <a href="http://courses.cms.caltech.edu/cs11/material/c/mike/misc/compiling_c.html">this</a>.</p>

<h2>Writing a Makefile</h2>

<p>Using <code>make</code> is mostly about writing a <code>Makefile</code>,
so we will discuss this first.</p>

<p>A <code>Makefile</code> consists mainly of:</p>

<ul>
<li>variable definitions</li>
<li>rules, which are instructions for remaking files or performing some other
actions.  Rules themselves consist of:
<ul>
<li>targets</li>
<li>dependencies</li>
<li>commands</li>
</ul></li>
</ul>

<p>A <b>target</b> is usually the name of a file that is generated by a
program; examples of targets are executables or object files.  A target can
also be the name of an action to carry out, such as <code>clean</code>, which
normally is set up to remove unwanted files.</p>

<p>A <b>dependency</b> is another target that has to be dealt with before the
current target is dealt with, and/or a file which the current target requires
in order to be executed.  Each target has a list of dependencies.  Most of
the time, dependencies are the names of other files that are used as input to
create a particular target, either directly or indirectly.  A target often
depends on several files, and a single file may be a dependency for several
other files.</p>

<p>A <b>command</b> is an action that the <code>make</code> program carries
out when a specific rule is invoked.  A rule may have more than one command,
each on its own line directly below the rule.  <font color="red"><b>PLEASE
NOTE: you need to put a tab character at the beginning of <i>every</i>
command line!</b></font> Forgetting to have the tab character at the
beginning of each command line is the most common mistake in writing a
Makefile.  Note that four or eight spaces can <b>not</b> be used in place of
the tab; it has to be the tab character itself (ascii 9 in hexadecimal).
This is really lame, but it's the way <code>make</code> works.</p>

<p>Usually a command is in a rule with dependencies and serves to create a
file with the same name as the target if any of the dependencies change.
However, the rule that specifies commands for the target does not have to
have dependencies.  For example, the rule containing the commands associated
with the target <code>clean</code> in the sample Makefile below does not have
dependencies.</p>


<h4>A simple <code>Makefile</code></h4>

<p>Here is a straightforward <code>Makefile</code> that describes the way an
executable file called <code>edit</code> depends on eight object files which,
in turn, depend on eight C source code files and three C header files.</p>

<p>In this example, all the C files include <code>defs.h</code>, but only
those defining editing commands include <code>command.h</code>, and only low
level files that change the editor buffer include <code>buffer.h</code>.</p>

<pre>    # Beginning of Makefile.

    CC = gcc

    edit: main.o kbd.o command.o display.o insert.o search.o files.o utils.o
        $(CC) -o edit main.o kbd.o command.o display.o \
              insert.o search.o files.o utils.o

    main.o: main.c defs.h
        $(CC) -c main.c

    kbd.o : kbd.c defs.h command.h
        $(CC) -c kbd.c

    command.o: command.c defs.h command.h
        $(CC) -c command.c

    display.o: display.c defs.h buffer.h
        $(CC) -c display.c

    insert.o: insert.c defs.h buffer.h
        $(CC) -c insert.c

    search.o: search.c defs.h buffer.h
        $(CC) -c search.c

    files.o: files.c defs.h buffer.h command.h
        $(CC) -c files.c

    utils.o: utils.c defs.h
        $(CC) -c utils.c

    clean:
        rm edit main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

    # End of Makefile.
</pre>

<p>We split each long line into two lines using backslash-newline; this is
like using one long line, but is easier to read.  Note also that the
<code>#</code> symbol means that the rest of the line is a comment.  (This is
different from comments in C; remember, a <code>Makefile</code> is <u>not</u>
C code!)</p>

<p>As you can see, this <code>Makefile</code> contains ten different targets.
One of them is the <code>edit</code> program, one is called
<code>clean</code>, and the rest are C object code files (files ending in
.o).  There is also a single variable called <code>CC</code> (which by
convention refers to the C compiler), which we set to be <code>gcc</code>.
Variables are defined by writing

</p><pre>    &lt;variable-name&gt; = &lt;value&gt;
</pre>

<p>and are used by writing <code>$(&lt;variable-name&gt;)</code> where
needed.</p>

<p>Each rule has the form:</p>

<pre>    &lt;target&gt;: [&lt;dependency1&gt; &lt;dependency2&gt; ... ]
    &lt;tab&gt;rule
    &lt;tab&gt;rule
    etc.
</pre>

<h2>Invoking <code>make</code></h2>

<p>When you type:</p>

<pre>    % make
</pre>

<p>at the unix prompt (which is <code>%</code> here), the <code>make</code>
program will look through the <code>Makefile</code> to find the first target
in the file and then execute the commands appropriate for that target.  This
is known as the default target.  If you want some other target, you have to
specify it explicitly on the command line.  For instance, to execute the
commands for the "clean" target you would do</p>

<pre>    % make clean
</pre>

<p>In the <code>Makefile</code> shown above, the default target is
<code>edit</code>, so typing <code>make</code> will cause the make program to
try to rebuild the <code>edit</code> program.</p>

<p>When make starts rebuilding <code>edit</code>, the first thing it does is
to determine whether it even has to rebuild it.  To do this, it does the
following:</p>

<ol>

<li><p>For each of <code>edit</code>'s dependencies, <code>make</code> checks
to see if it's a file, and if so, if the file needs to be remade, and if so,
remakes it (assuming there is a rule to remake it).  If a file exists and
there is no rule to remake the file (as is the case with source code files,
for instance), <code>make</code> assumes that the file is
up-to-date.</p></li>

<li><p>Assuming all of <code>edit</code>'s dependencies are up-to-date, make
checks to see if any of the dependency files have been modified more recently
than <code>edit</code> itself has been.  If so, it will execute the
command(s) corresponding to the <code>edit</code> target.  It does this by
substituting variable values for variable references and then executing the
resulting command(s).</p>

<p>If none of the dependency files have been modified more recently than the
<code>edit</code> program itself, make will do nothing and will report that
<code>edit</code> is up-to-date.</p></li>

</ol>

<p>Note that if <code>edit</code> has never been compiled before, then make
will try to compile it.  If the name of the target is <b>not</b> the name of
a file (<i>e.g.</i> the <code>clean</code> target), then make will always
invoke the commands for that target when asked to make that target.</p>

<h2>What's the point?</h2>

<p>At this point you may be wondering why we need such a complicated system
just to compile a few files.  Here's why.  Let's say that you modified the
source code files <code>command.c</code> and <code>command.h</code> and want
to recompile <code>edit</code>.  What you don't want to do is to recompile
every single source code file in the program.  What you also don't want to do
is to fail to recompile files that depend on either of these two files (for
instance, <code>kbd.o</code> and <code>files.o</code> also depend on
<code>command.h</code>).  By letting <code>make</code> keep track of all the
dependencies, you guarantee that when you modify some files, only the files
that really need to be recompiled will be recompiled.  This will usually only
be a small fraction of the total number of source code files in a large
project.  For instance, if you modify one file in a project that has 1000
source code files (which is by no means rare), and ten other source code
files in various directories depend on the file you modified, then only your
file, the ten other source code files, and the final executable will be
remade.  That's obviously much faster than recompiling all 1000 source code
files.</p>

<h2>Using variables to keep things concise</h2>

<p>Here is a shorter version of the <code>Makefile</code> above:</p>

<pre>    # Beginning of Makefile.

    CC = gcc
    OBJS = main.o kbd.o command.o display.o insert.o search.o files.o utils.o

    edit: $(OBJS)
        $(CC) -o edit $(OBJS)

    main.o: main.c defs.h
        $(CC) -c main.c

    kbd.o : kbd.c defs.h command.h
        $(CC) -c kbd.c

    command.o: command.c defs.h command.h
        $(CC) -c command.c

    display.o: display.c defs.h buffer.h
        $(CC) -c display.c

    insert.o: insert.c defs.h buffer.h
        $(CC) -c insert.c

    search.o: search.c defs.h buffer.h
        $(CC) -c search.c

    files.o: files.c defs.h buffer.h command.h
        $(CC) -c files.c

    utils.o: utils.c defs.h
        $(CC) -c utils.c

    clean:
        rm edit $(OBJS)

    # End of Makefile.
</pre>

<p>The only change is that we replaced the line <code>main.o kbd.o command.o
display.o insert.o search.o files.o utils.o</code> (which occurred in three
places) with <code>$(OBJS)</code> (which stands for "object files", although
we could have used any name).  This is convenient, because if we choose to
change the name of one of the files, we only have to change it in the
definition of OBJS and in the actual rule that makes the object file.  The
other uses of the file will read the variable definition and automatically
get the new name.  Defining variable names like this will make your
<code>Makefile</code>s easier to manage.</p>


<h2>Finally...</h2>

<p>There is much, much more to <code>make</code> than we have time to go into
here.  Please consult the references or ask your helpful instructor if you
want/need to know more.</p>


<h2>References</h2>

<ul>

<li>Andrew Oram, <u>Managing Projects with Make</u>.  O'Reilly and Associates.</li>

<li>The GNU Info documentation on <code>make</code>.  Type "<code>info
make</code>" at the unix prompt to access this.</li>

</ul>

<hr>



</body></html>